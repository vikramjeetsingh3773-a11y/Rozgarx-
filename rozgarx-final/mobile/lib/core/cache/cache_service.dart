// lib/core/cache/cache_service.dart
// ============================================================
// RozgarX AI — Offline Cache Service
// Uses Hive for local storage, Firestore offline persistence
// for real-time sync, and smart invalidation.
//
// Cache strategy:
//   - Jobs list: 6 hours (refreshed on app foreground)
//   - Saved jobs: indefinite (user-owned, sync on reconnect)
//   - PDFs: LRU cache, max 50MB (last 20 PDFs)
//   - Job details: 24 hours per job
// ============================================================

import 'dart:async';
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:path_provider/path_provider.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import '../models/job_model.dart';

class CacheService {
  static const _jobsBoxName       = 'jobs_cache';
  static const _savedJobsBoxName  = 'saved_jobs';
  static const _metaBoxName       = 'cache_meta';
  static const _userBoxName       = 'user_cache';

  // Cache TTLs
  static const _jobListTTL    = Duration(hours: 6);
  static const _jobDetailTTL  = Duration(hours: 24);
  static const _maxPDFCacheMB = 50;
  static const _maxCachedPDFs = 20;

  late Box<JobModel>  _jobsBox;
  late Box<JobModel>  _savedJobsBox;
  late Box<dynamic>   _metaBox;
  late Box<dynamic>   _userBox;

  bool _initialized = false;
  final _connectivity = Connectivity();

  // PDF cache manager with size limits
  static final pdfCacheManager = CacheManager(
    Config(
      'rozgarx_pdf_cache',
      stalePeriod: const Duration(days: 7),
      maxNrOfCacheObjects: _maxCachedPDFs,
    ),
  );


  // ── INITIALIZATION
  Future<void> init() async {
    if (_initialized) return;

    await Hive.initFlutter();

    // Register adapters (generated by hive_generator)
    if (!Hive.isAdapterRegistered(0)) Hive.registerAdapter(JobModelAdapter());
    if (!Hive.isAdapterRegistered(1)) Hive.registerAdapter(JobBasicInfoAdapter());
    if (!Hive.isAdapterRegistered(2)) Hive.registerAdapter(JobImportantDatesAdapter());
    if (!Hive.isAdapterRegistered(3)) Hive.registerAdapter(JobEligibilityAdapter());
    if (!Hive.isAdapterRegistered(4)) Hive.registerAdapter(JobApplicationDetailsAdapter());
    if (!Hive.isAdapterRegistered(5)) Hive.registerAdapter(JobAnalyticsAdapter());
    if (!Hive.isAdapterRegistered(6)) Hive.registerAdapter(JobVacanciesAdapter());
    if (!Hive.isAdapterRegistered(7)) Hive.registerAdapter(JobMetadataAdapter());
    if (!Hive.isAdapterRegistered(8)) Hive.registerAdapter(SyllabusItemAdapter());
    if (!Hive.isAdapterRegistered(9)) Hive.registerAdapter(SelectionStageAdapter());
    if (!Hive.isAdapterRegistered(10)) Hive.registerAdapter(ExamPatternAdapter());

    _jobsBox      = await Hive.openBox<JobModel>(_jobsBoxName);
    _savedJobsBox = await Hive.openBox<JobModel>(_savedJobsBoxName);
    _metaBox      = await Hive.openBox(_metaBoxName);
    _userBox      = await Hive.openBox(_userBoxName);

    _initialized = true;
    debugPrint('[Cache] Initialized. Jobs cached: ${_jobsBox.length}');
  }


  // ── NETWORK STATUS
  Future<bool> get isOnline async {
    final result = await _connectivity.checkConnectivity();
    return result != ConnectivityResult.none;
  }

  Stream<bool> get onlineStream => _connectivity.onConnectivityChanged
      .map((r) => r != ConnectivityResult.none);


  // ── JOB LIST CACHE

  Future<void> cacheJobList(
    String cacheKey,
    List<JobModel> jobs,
  ) async {
    // Store each job by ID
    for (final job in jobs) {
      await _jobsBox.put(job.jobId, job);
    }

    // Store the index (list of IDs for this query)
    final index = jobs.map((j) => j.jobId).toList();
    await _metaBox.put('index_$cacheKey', index);
    await _metaBox.put('ts_$cacheKey', DateTime.now().millisecondsSinceEpoch);

    debugPrint('[Cache] Cached ${jobs.length} jobs for key: $cacheKey');
  }

  List<JobModel>? getCachedJobList(String cacheKey) {
    // Check TTL
    final ts = _metaBox.get('ts_$cacheKey') as int?;
    if (ts == null) return null;

    final age = DateTime.now().millisecondsSinceEpoch - ts;
    if (age > _jobListTTL.inMilliseconds) {
      debugPrint('[Cache] List expired for key: $cacheKey');
      return null;
    }

    final index = _metaBox.get('index_$cacheKey') as List?;
    if (index == null) return null;

    final jobs = <JobModel>[];
    for (final id in index) {
      final job = _jobsBox.get(id as String);
      if (job != null) jobs.add(job);
    }

    if (jobs.isEmpty) return null;
    debugPrint('[Cache] Hit: ${jobs.length} jobs for key: $cacheKey');
    return jobs;
  }

  bool isJobListStale(String cacheKey) {
    final ts = _metaBox.get('ts_$cacheKey') as int?;
    if (ts == null) return true;
    final age = DateTime.now().millisecondsSinceEpoch - ts;
    return age > _jobListTTL.inMilliseconds;
  }


  // ── SINGLE JOB CACHE

  Future<void> cacheJob(JobModel job) async {
    await _jobsBox.put(job.jobId, job);
    await _metaBox.put('job_ts_${job.jobId}', DateTime.now().millisecondsSinceEpoch);
  }

  JobModel? getCachedJob(String jobId) {
    final ts = _metaBox.get('job_ts_$jobId') as int?;
    if (ts != null) {
      final age = DateTime.now().millisecondsSinceEpoch - ts;
      if (age > _jobDetailTTL.inMilliseconds) return null;
    }
    return _jobsBox.get(jobId);
  }


  // ── SAVED JOBS (offline-persistent, sync on reconnect)

  Future<void> saveJob(JobModel job) async {
    final updated = job.copyWith(isSaved: true);
    await _savedJobsBox.put(job.jobId, updated);
    await _jobsBox.put(job.jobId, updated);

    // Queue sync if offline
    if (!await isOnline) {
      await _queueSync('save_job', job.jobId);
    }
  }

  Future<void> unsaveJob(String jobId) async {
    await _savedJobsBox.delete(jobId);
    final cached = _jobsBox.get(jobId);
    if (cached != null) {
      await _jobsBox.put(jobId, cached.copyWith(isSaved: false));
    }
    if (!await isOnline) {
      await _queueSync('unsave_job', jobId);
    }
  }

  List<JobModel> getSavedJobs() {
    return _savedJobsBox.values.toList()
      ..sort((a, b) => (b.lastViewedAt ?? DateTime(0))
          .compareTo(a.lastViewedAt ?? DateTime(0)));
  }

  bool isJobSaved(String jobId) => _savedJobsBox.containsKey(jobId);


  // ── OFFLINE SYNC QUEUE
  // Operations done offline are queued and flushed when back online.

  Future<void> _queueSync(String action, String jobId) async {
    final queue = List<Map<String, dynamic>>.from(
      (_metaBox.get('sync_queue') as List? ?? []).cast<Map<String, dynamic>>()
    );
    queue.add({
      'action': action,
      'jobId': jobId,
      'queuedAt': DateTime.now().toIso8601String(),
    });
    await _metaBox.put('sync_queue', queue);
  }

  List<Map<String, dynamic>> getPendingSyncQueue() {
    return List<Map<String, dynamic>>.from(
      (_metaBox.get('sync_queue') as List? ?? []).cast<Map<String, dynamic>>()
    );
  }

  Future<void> clearSyncQueue() async {
    await _metaBox.delete('sync_queue');
  }


  // ── PDF CACHE

  Future<File?> getCachedPDF(String url) async {
    try {
      final fileInfo = await pdfCacheManager.getFileFromCache(url);
      return fileInfo?.file;
    } catch (_) {
      return null;
    }
  }

  Future<File?> downloadAndCachePDF(
    String url, {
    ValueChanged<double>? onProgress,
  }) async {
    try {
      // Check cache size before downloading
      await _enforcePDFCacheLimit();

      final stream = pdfCacheManager.getFileStream(url, withProgress: true);

      File? file;
      await for (final result in stream) {
        if (result is DownloadProgress && onProgress != null) {
          final progress = result.totalSize != null
              ? result.downloaded / result.totalSize!
              : 0.0;
          onProgress(progress);
        } else if (result is FileInfo) {
          file = result.file;
        }
      }
      return file;
    } catch (e) {
      debugPrint('[Cache] PDF download failed: $e');
      return null;
    }
  }

  Future<void> _enforcePDFCacheLimit() async {
    try {
      final cacheDir = await getTemporaryDirectory();
      final cacheFolder = Directory('${cacheDir.path}/libCachedImageData');
      if (!await cacheFolder.exists()) return;

      final files = await cacheFolder.list().toList();
      if (files.length > _maxCachedPDFs) {
        // Remove oldest files
        files.sort((a, b) {
          final aStat = File(a.path).statSync();
          final bStat = File(b.path).statSync();
          return aStat.modified.compareTo(bStat.modified);
        });
        for (int i = 0; i < files.length - _maxCachedPDFs; i++) {
          await File(files[i].path).delete();
        }
      }
    } catch (_) {}
  }


  // ── BANDWIDTH CATEGORY (stored from first app launch)

  Future<void> saveBandwidthCategory(String category) async {
    await _userBox.put('bandwidthCategory', category);
    await _userBox.put('bandwidthDetectedAt',
        DateTime.now().millisecondsSinceEpoch);
  }

  String get bandwidthCategory =>
      _userBox.get('bandwidthCategory') as String? ?? 'medium';

  bool get isLowBandwidth => bandwidthCategory == 'low';


  // ── CACHE INVALIDATION

  Future<void> invalidateCategory(String category) async {
    final keys = _metaBox.keys
        .where((k) => k.toString().startsWith('index_$category'))
        .toList();
    for (final key in keys) {
      await _metaBox.delete(key);
      await _metaBox.delete(key.toString().replaceFirst('index_', 'ts_'));
    }
    debugPrint('[Cache] Invalidated category: $category');
  }

  Future<void> invalidateAll() async {
    await _jobsBox.clear();
    await _metaBox.clear();
    debugPrint('[Cache] Full invalidation complete');
  }

  Future<void> invalidateExpiredJobs() async {
    final now = DateTime.now();
    final expiredKeys = <String>[];

    for (final job in _jobsBox.values) {
      if (job.importantDates.lastDate != null &&
          job.importantDates.lastDate!.isBefore(
              now.subtract(const Duration(days: 7)))) {
        expiredKeys.add(job.jobId);
      }
    }

    for (final key in expiredKeys) {
      await _jobsBox.delete(key);
    }

    debugPrint('[Cache] Removed ${expiredKeys.length} expired jobs');
  }


  // ── LAST SEARCH STATE (restore on resume)

  Future<void> saveLastSearchState({
    String? category,
    String? state,
    String? query,
  }) async {
    await _metaBox.put('lastCategory', category);
    await _metaBox.put('lastState', state);
    await _metaBox.put('lastQuery', query);
  }

  Map<String, String?> getLastSearchState() => {
    'category': _metaBox.get('lastCategory') as String?,
    'state': _metaBox.get('lastState') as String?,
    'query': _metaBox.get('lastQuery') as String?,
  };


  // ── DIAGNOSTICS

  Map<String, dynamic> getCacheStats() => {
    'cachedJobs': _jobsBox.length,
    'savedJobs': _savedJobsBox.length,
    'pendingSyncs': getPendingSyncQueue().length,
    'bandwidthCategory': bandwidthCategory,
  };
}
